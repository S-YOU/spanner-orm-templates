// Code generated by yo. DO NOT EDIT.
package repository

import (
	"bytes"
	"context"
	"encoding/binary"
	"encoding/gob"
	"errors"
	"fmt"
	"reflect"
	"time"

	"cloud.google.com/go/spanner"
	"google.golang.org/api/iterator"

	"github.com/cespare/xxhash"
	"github.com/s-you/apierrors"
	"github.com/s-you/spannerbuilder"
	"github.com/s-you/yo-templates/internal/middleware"
	"github.com/s-you/yo-templates/internal/model"
)

type Repository struct {
	client *spanner.Client
}

type Params = map[string]interface{}

var (
	ErrNotFound = errors.New("NotFound")
)

func getCacheKey(stmt spanner.Statement) (string, error) {
	sum64 := xxhash.Sum64String(stmt.SQL)
	buf := new(bytes.Buffer)
	cacheKey := make([]byte, 8)
	binary.LittleEndian.PutUint64(cacheKey, sum64)
	buf.Write(cacheKey)
	e := gob.NewEncoder(buf)
	err := e.Encode(stmt.Params)
	if err != nil {
		return "", err
	}
	return buf.String(), nil
}

func intoAny(iter *spanner.RowIterator, cols []string, into interface{}) error {
	defer iter.Stop()
	if reflect.TypeOf(into).Kind() != reflect.Ptr {
		return fmt.Errorf("intoAny: argument is not pointer")
	}
	if len(cols) != 1 {
		return fmt.Errorf("intoAny: multiple column not supported, use .Into instead")
	}
	value := reflect.ValueOf(into)

	row, err := iter.Next()
	if err != nil {
		if err == iterator.Done {
			return ErrNotFound
		}
		return fmt.Errorf("intoAny.iter: %w", err)
	}

	g := reflect.New(value.Elem().Type())
	err = row.Column(0, g.Interface())
	if err != nil {
		return fmt.Errorf("intoAny.Column: %w", err)
	}
	value.Elem().Set(g.Elem())

	return nil
}

func intosAnySlice(iter *spanner.RowIterator, cols []string, into interface{}) error {
	defer iter.Stop()
	if reflect.TypeOf(into).Kind() != reflect.Ptr {
		return fmt.Errorf("intosAnySlice: argument is not pointer")
	}
	if len(cols) != 1 {
		return fmt.Errorf("intosAnySlice: multiple column not supported, use .Intos instead")
	}
	value := reflect.ValueOf(into)
	elem := value.Elem()
	elemType := reflect.MakeSlice(elem.Type(), 1, 1).Index(0).Type()

	for {
		row, err := iter.Next()
		if err != nil {
			if err == iterator.Done {
				break
			}
			return fmt.Errorf("intosAnySlice.iter: %w", err)
		}

		g := reflect.New(elemType)
		err = row.Column(0, g.Interface())
		if err != nil {
			return fmt.Errorf("intosAnySlice.Column: %w", err)
		}

		elem = reflect.Append(elem, g.Elem())
		value.Elem().Set(elem)
	}

	return nil
}

type userRepository struct {
	Repository
}

type userBuilder struct {
	b      *spannerbuilder.Builder
	client *spanner.Client
}

type userIterator struct {
	*spanner.RowIterator
	cols []string
}

type UserRepositoryGenerated interface {
	GetUserByUserID(ctx context.Context, userID string) (*model.User, error)
	GetUserByUserIDCached(ctx context.Context, userID string) (*model.User, error)
	FindUserByUserIDs(ctx context.Context, ids []string) ([]*model.User, error)
	FindUserByUserIDsCached(ctx context.Context, ids []string) ([]*model.User, error)
	FindUsersByName(ctx context.Context, name string) ([]*model.User, error)
	FindUsersByNameCached(ctx context.Context, name string) ([]*model.User, error)
	FindUsersByNames(ctx context.Context, ids []string) ([]*model.User, error)
	FindUsersByNamesCached(ctx context.Context, ids []string) ([]*model.User, error)
}

type UserRepositoryCrud interface {
	FindAll(ctx context.Context) ([]*model.User, error)
	FindAllWithCursor(ctx context.Context, limit int, cursor string) ([]*model.User, error)
	CreateUser(ctx context.Context, name string, status int64) (*model.User, error)
	CreateOrUpdateUser(ctx context.Context, name string, status int64) (*model.User, error)
	InsertUser(ctx context.Context, user *model.User) (*model.User, error)
	UpdateUser(ctx context.Context, user *model.User) error
	DeleteUser(ctx context.Context, user *model.User) error
}

func NewUserRepository(client *spanner.Client) UserRepository {
	return &userRepository{
		Repository: Repository{
			client: client,
		},
	}
}

func (u *userRepository) Query(ctx context.Context, stmt spanner.Statement) *userIterator {
	iter := u.client.Single().Query(ctx, stmt)

	return &userIterator{iter, model.UserColumns()}
}

func (u *userRepository) Insert(ctx context.Context, user *model.User) (*time.Time, error) {
	if err := user.SetIdentity(); err != nil {
		return nil, err
	}
	if user.CreatedAt.IsZero() {
		user.CreatedAt = time.Now()
	}
	if user.UpdatedAt.IsZero() {
		user.UpdatedAt = time.Now()
	}

	mutations := []*spanner.Mutation{
		user.Insert(ctx),
	}
	t, err := u.client.Apply(ctx, mutations)
	if err != nil {
		return nil, err
	}
	return &t, nil
}

func (u *userRepository) InsertOrUpdate(ctx context.Context, user *model.User) (time.Time, error) {
	if err := user.SetIdentity(); err != nil {
		return time.Time{}, err
	}
	if user.CreatedAt.IsZero() {
		user.CreatedAt = time.Now()
	}
	if user.UpdatedAt.IsZero() {
		user.UpdatedAt = time.Now()
	}

	mutations := []*spanner.Mutation{
		user.InsertOrUpdate(ctx),
	}
	t, err := u.client.Apply(ctx, mutations)
	if err != nil {
		return time.Time{}, err
	}
	return t, nil
}

func (u *userRepository) Update(ctx context.Context, user *model.User) (*time.Time, error) {
	if user.UserID == "" {
		return nil, fmt.Errorf("primary_key `user_id` is blank")
	}
	if user.CreatedAt.IsZero() {
		return nil, fmt.Errorf("created_at is blank")
	}
	user.UpdatedAt = time.Now()

	mutations := []*spanner.Mutation{
		user.Update(ctx),
	}
	t, err := u.client.Apply(ctx, mutations)
	if err != nil {
		return nil, err
	}
	return &t, nil
}

func (u *userRepository) UpdateColumns(ctx context.Context, user *model.User, cols ...string) (*time.Time, error) {
	if user.UserID == "" {
		return nil, fmt.Errorf("primary_key `user_id` is blank")
	}
	if user.CreatedAt.IsZero() {
		return nil, fmt.Errorf("created_at is blank")
	}
	user.UpdatedAt = time.Now()

	mutation, err := user.UpdateColumns(ctx, cols...)
	if err != nil {
		return nil, err
	}
	mutations := []*spanner.Mutation{mutation}
	t, err := u.client.Apply(ctx, mutations)
	if err != nil {
		return nil, err
	}
	return &t, nil
}

func (u *userRepository) UpdateMap(ctx context.Context, user *model.User, userMap map[string]interface{}) (*time.Time, error) {
	if user.UserID == "" {
		return nil, fmt.Errorf("primary_key `user_id` is blank")
	}
	if user.CreatedAt.IsZero() {
		return nil, fmt.Errorf("created_at is blank")
	}
	user.UpdatedAt = time.Now()

	mutation := user.UpdateMap(ctx, userMap)
	mutations := []*spanner.Mutation{mutation}
	t, err := u.client.Apply(ctx, mutations)
	if err != nil {
		return nil, err
	}
	return &t, nil
}

func (u *userRepository) Delete(ctx context.Context, user *model.User) (*time.Time, error) {
	if user.UserID == "" {
		return nil, fmt.Errorf("primary_key `user_id` is blank")
	}
	if user.CreatedAt.IsZero() {
		return nil, fmt.Errorf("created_at is blank")
	}
	user.UpdatedAt = time.Now()

	mutation := user.Delete(ctx)
	mutations := []*spanner.Mutation{mutation}
	t, err := u.client.Apply(ctx, mutations)
	if err != nil {
		return nil, err
	}
	return &t, nil
}

func (u *userRepository) Builder() *userBuilder {
	return &userBuilder{
		b:      spannerbuilder.NewSpannerBuilder("users", model.UserColumns(), model.UserPrimaryKeys()),
		client: u.client,
	}
}

func (b *userBuilder) Select(s string) *userBuilder {
	b.b.Select(s)
	return b
}

func (b *userBuilder) Join(s string) *userBuilder {
	b.b.Join(s)
	return b
}

func (b *userBuilder) Where(s string, args ...interface{}) *userBuilder {
	b.b.Where(s, args...)
	return b
}

func (b *userBuilder) OrderBy(s string) *userBuilder {
	b.b.OrderBy(s)
	return b
}

func (b *userBuilder) Limit(i int) *userBuilder {
	b.b.Limit(i)
	return b
}

func (b *userBuilder) Query(ctx context.Context) *userIterator {
	stmt := b.b.GetSelectStatement()
	iter := b.client.Single().Query(ctx, stmt)
	return &userIterator{iter, b.b.Columns()}
}

func (iter *userIterator) Into(into *model.User) error {
	defer iter.Stop()

	row, err := iter.Next()
	if err != nil {
		if err == iterator.Done {
			return apierrors.ErrNotFound.Swrapf("User not found: %w", ErrNotFound)
		}
		return fmt.Errorf("into.iter: %w", err)
	}

	err = model.User_DecodeInto(iter.cols, row, into)
	if err != nil {
		return fmt.Errorf("into.decoder: %w", err)
	}

	return nil
}

func (iter *userIterator) Intos(into *[]*model.User) error {
	defer iter.Stop()

	for {
		row, err := iter.Next()
		if err != nil {
			if err == iterator.Done {
				break
			}
			return fmt.Errorf("Intos.iter: %w", err)
		}

		u := &model.User{}
		err = model.User_DecodeInto(iter.cols, row, u)
		if err != nil {
			return fmt.Errorf("Intos.iter: %w", err)
		}

		*into = append(*into, u)
	}

	return nil
}

func (iter *userIterator) IntoAny(into interface{}) error {
	if err := intoAny(iter.RowIterator, iter.cols, into); err != nil {
		if err == ErrNotFound {
			return apierrors.ErrNotFound.Swrapf("User not found: %w", err)
		}
		return err
	}
	return nil
}

func (iter *userIterator) IntosAnySlice(into interface{}) error {
	return intosAnySlice(iter.RowIterator, iter.cols, into)
}

func (b *userBuilder) QueryCachedInto(ctx context.Context, into **model.User) error {
	stmt := b.b.GetSelectStatement()
	cacheKey, err := getCacheKey(stmt)
	if err != nil {
		return err
	}

	cached := middleware.CacheFromContext(ctx)
	if v, ok := cached.Get(cacheKey); ok {
		if *into, ok = v.(*model.User); ok {
			return nil
		}
	}
	iter := b.client.Single().Query(ctx, stmt)
	it := &userIterator{iter, b.b.Columns()}
	err = it.Into(*into)
	if err != nil {
		return err
	}
	cached.Set(cacheKey, *into)

	return nil
}

func (b *userBuilder) QueryCachedIntos(ctx context.Context, into *[]*model.User) error {
	stmt := b.b.GetSelectStatement()
	cacheKey, err := getCacheKey(stmt)
	if err != nil {
		return err
	}

	cache := middleware.CacheFromContext(ctx)
	if v, ok := cache.Get(cacheKey); ok {
		if *into, ok = v.([]*model.User); ok {
			return nil
		}
	}
	iter := b.client.Single().Query(ctx, stmt)
	it := &userIterator{iter, b.b.Columns()}
	err = it.Intos(into)
	if err != nil {
		return err
	}
	cache.Set(cacheKey, *into)

	return nil
}

// GetUserByUserID retrieves a row from 'users' as a User.
// Generated from primary key
func (u userRepository) GetUserByUserID(ctx context.Context, userID string) (*model.User, error) {
	user := &model.User{}
	if err := u.Builder().
		Where("user_id = @param0", Params{"param0": userID}).
		Query(ctx).Into(user); err != nil {
		return nil, err
	}

	return user, nil
}

// GetUserByUserIDCached retrieves a row from cache or 'users' as a User.
// Generated from primary key
func (u userRepository) GetUserByUserIDCached(ctx context.Context, userID string) (*model.User, error) {
	user := &model.User{}
	if err := u.Builder().
		Where("user_id = @param0", Params{"param0": userID}).
		QueryCachedInto(ctx, &user); err != nil {
		return nil, err
	}

	return user, nil
}

// FindUserByUserIDs retrieves multiple rows from 'users' as []*model.User.
// Generated from primary key
func (u userRepository) FindUserByUserIDs(ctx context.Context, ids []string) ([]*model.User, error) {
	var items []*model.User
	if err := u.Builder().Where("user_id IN UNNEST(?)", ids).Query(ctx).Intos(&items); err != nil {
		return nil, err
	}

	return items, nil
}

// FindUserByUserIDsCached retrieves multiple rows from 'users' or cache as []*model.User.
// Generated from primary key
func (u userRepository) FindUserByUserIDsCached(ctx context.Context, ids []string) ([]*model.User, error) {
	var items []*model.User
	if err := u.Builder().Where("user_id IN UNNEST(?)", ids).QueryCachedIntos(ctx, &items); err != nil {
		return nil, err
	}

	return items, nil
}

func (u userRepository) FindAll(ctx context.Context) ([]*model.User, error) {
	var items []*model.User
	if err := u.Builder().Query(ctx).Intos(&items); err != nil {
		return nil, err
	}

	return items, nil
}

func (u userRepository) FindAllWithCursor(ctx context.Context, limit int, cursor string) ([]*model.User, error) {
	items := make([]*model.User, 0)
	builder := u.Builder()
	if cursor != "" {
		builder.Where("user_id < ?", cursor)
	}
	if err := builder.OrderBy("user_id DESC").Limit(limit).Query(ctx).Intos(&items); err != nil {
		return nil, err
	}

	return items, nil
}

func (u userRepository) InsertUser(ctx context.Context, user *model.User) (*model.User, error) {
	if _, err := u.Insert(ctx, user); err != nil {
		return nil, err
	}

	return user, nil
}

func (u userRepository) CreateUser(ctx context.Context, name string, status int64) (*model.User, error) {
	userEntity := &model.User{Name: name, Status: status}
	if _, err := u.Insert(ctx, userEntity); err != nil {
		return nil, err
	}

	return userEntity, nil
}

func (u userRepository) CreateOrUpdateUser(ctx context.Context, name string, status int64) (*model.User, error) {
	userEntity := &model.User{Name: name, Status: status}
	if _, err := u.InsertOrUpdate(ctx, userEntity); err != nil {
		return nil, err
	}

	return userEntity, nil
}

func (u userRepository) UpdateUser(ctx context.Context, user *model.User) error {
	_, err := u.Update(ctx, user)
	if err != nil {
		return err
	}
	return nil
}

func (u userRepository) DeleteUser(ctx context.Context, user *model.User) error {
	_, err := u.Delete(ctx, user)
	if err != nil {
		return err
	}
	return nil
}

// GetUsersByName retrieves multiple rows from 'users' as a slice of User.
// Generated from index 'idx_users_name'.
func (u userRepository) FindUsersByName(ctx context.Context, name string) ([]*model.User, error) {
	user := []*model.User{}
	if err := u.Builder().
		Where("name = @param0", Params{"param0": name}).
		Query(ctx).Intos(&user); err != nil {
		return nil, err
	}

	return user, nil
}

// GetUsersByNameCached retrieves multiple rows from cache or 'users' as a slice of User.
// Generated from index 'idx_users_name'.
func (u userRepository) FindUsersByNameCached(ctx context.Context, name string) ([]*model.User, error) {
	user := []*model.User{}
	if err := u.Builder().
		Where("name = @param0", Params{"param0": name}).
		QueryCachedIntos(ctx, &user); err != nil {
		return nil, err
	}

	return user, nil
}

// FindUsersByNames retrieves multiple rows from 'users' as []*model.User.
// Generated from unique index 'idx_users_name'.
func (u userRepository) FindUsersByNames(ctx context.Context, ids []string) ([]*model.User, error) {
	var items []*model.User
	if err := u.Builder().Where("name IN UNNEST(?)", ids).Query(ctx).Intos(&items); err != nil {
		return nil, err
	}

	return items, nil
}

// FindUsersByNamesCached retrieves multiple rows from 'users' or from cache as []*model.User.
// Generated from unique index 'idx_users_name'.
func (u userRepository) FindUsersByNamesCached(ctx context.Context, ids []string) ([]*model.User, error) {
	var items []*model.User
	if err := u.Builder().Where("name IN UNNEST(?)", ids).QueryCachedIntos(ctx, &items); err != nil {
		return nil, err
	}

	return items, nil
}
